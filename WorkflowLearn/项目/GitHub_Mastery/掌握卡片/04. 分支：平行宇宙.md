# 掌握卡片/04. 分支：平行宇宙.md

## 我的理解
分支不是代码的物理拷贝，而是指向提交记录的**指针（书签/旗子）**。
- **隔离性**：分支之间是平行宇宙，改动互不干扰，直到发生 Merge。
- **HEAD 的本质**：它是你的“当前视角”，通常指向一个分支，分支再指向 Commit。
- **游离状态 (Detached HEAD)**：当 HEAD 直接指向 Commit 而非分支时，你会处于一种没有“救生索”的状态，此时的提交如果不赶紧挂载到分支上，就会变成“无主孤魂”。

## 🏀 类比挂钩
*导师与我的对话精华*
我：我怀疑书签这个例子是有问题的... 应该是平行时空里的两本书。
导师：你说得对。Git 更像是一棵树。在分叉点（Base）之前共享历史，之后各自生长出不同的枝干。
我：如果是为了修 bug，应该往 bugfix 这个分支上 push 才对。
导师：逻辑完全正确。只有当你的灵魂（HEAD）投射在某个分支上时，该分支的指针才会随着你的提交而向前移动。

## 踩过的坑
- **数据残留误区**：以为删了分支代码就立刻物理消失了。
- **真相**：删除分支只是删除了 40 字节的指针，代码实体（Commit）变成了“无主孤魂”（Dangling Object），在被垃圾回收（GC）之前是可以找回的。
- **游离风险**：在 Detached HEAD 状态下工作，切回主分支后，刚才的工作进度会因为没有指针引用而“失踪”。

## 源真理定义
> **Branching**：Git 中的分支本质上是一个指向提交对象的可变指针。
> **HEAD**：一个特殊的指针，指向当前检出的分支或具体的提交。
> **Detached HEAD**：当 HEAD 指向具体的提交哈希而非分支引用时，仓库处于游离状态。

## 关联
- 前置节点：[[03. 穿越：时光倒流]]（理解指针移动的本质）
- 后续节点：[[05. PR工作流]]（分支的协作实践）

## 💪 实操挑战
- [ ] 创建一个分支并切换过去，修改文件后切回 main，观察文件内容是否真的“变回来了”。
- [ ] 故意进入 Detached HEAD 状态做一个提交，然后切走，再尝试用 `git reflog` 找回它。
